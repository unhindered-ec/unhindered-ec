use std::{
    cmp::Ordering,
    fmt::{Debug, Display},
};

use rand::prelude::Distribution;

use super::{
    Individual,
    scorer::{FnScorer, Scorer},
};

/// A individual in the evolutionary computation system, consisting of a genome
/// and test results from scoring the genome.
///
/// The ordering of any [`EcIndividual`] is solely defined by the test results
/// (i.e. the scoring) of the individuals.
///
/// Usually this is generated by an [`IndividualDistribution`] wrapping a
/// genome generator.
///
/// # Example
/// ```
/// # use ec_core::individual::{Individual, ec::EcIndividual, scorer::{Scorer, FnScorer}};
/// #
/// let scorer_1 = FnScorer(|x: &i32| 11_i32.abs_diff(*x));
/// let scorer_2 = FnScorer(|x: &i32| 30_i32.abs_diff(*x));
///
/// let individual = EcIndividual::new(5, [scorer_1.score(&5), scorer_2.score(&5)]);
/// assert_eq!(individual.test_results(), &[6, 25]);
/// ```
#[derive(Debug, Eq, PartialEq, Clone, Hash, Default)]
#[expect(
    clippy::module_name_repetitions,
    reason = "This is legacy and arguably should be changed. Tracked in #221"
)]
pub struct EcIndividual<G, R> {
    pub genome: G,
    pub test_results: R,
}

impl<G, R> Individual for EcIndividual<G, R> {
    type Genome = G;
    type TestResults = R;

    /// Get the genome of the individual.
    ///
    /// # Example
    /// ```
    /// # use ec_core::individual::{Individual, ec::EcIndividual};
    /// #
    /// let individual = EcIndividual::new(5, []);
    /// #
    /// # // make type inference work.
    /// # let _: &EcIndividual<i32, [i32;0]> = &individual;
    ///
    /// assert_eq!(individual.genome(), &5);
    /// ```
    fn genome(&self) -> &Self::Genome {
        &self.genome
    }

    /// Get the test results of the individual.
    ///
    /// # Example
    /// ```
    /// # use ec_core::individual::{Individual, ec::EcIndividual, scorer::{Scorer, FnScorer}};
    /// #
    /// let scorer = FnScorer(|x: &i32| 21_i32.abs_diff(*x));
    ///
    /// let individual = EcIndividual::new(5, [scorer.score(&5)]);
    /// assert_eq!(individual.test_results(), &[16]);
    /// ```
    fn test_results(&self) -> &Self::TestResults {
        &self.test_results
    }
}

impl<G, R> EcIndividual<G, R> {
    /// Create a new [`EcIndividual`] with the given genome and test results.
    ///
    /// # Example
    /// ```
    /// # use ec_core::individual::{Individual, ec::EcIndividual};
    /// #
    /// let individual = EcIndividual::new((), []);
    /// #
    /// # // make type inference work.
    /// # let _: &EcIndividual<(), [i32;0]> = &individual;
    ///
    /// assert_eq!(individual.genome(), &());
    /// ```
    pub const fn new(genome: G, test_results: R) -> Self {
        Self {
            genome,
            test_results,
        }
    }
}

impl<G, R> From<(G, R)> for EcIndividual<G, R> {
    /// Create a new [`EcIndividual`] from a tuple of a Genome and test results.
    ///
    /// # Example
    /// ```
    /// # use ec_core::individual::{Individual, ec::EcIndividual};
    /// #
    /// let individual = EcIndividual::from((80, []));
    /// #
    /// # // make type inference work.
    /// # let _: &EcIndividual<i32, [i32;0]> = &individual;
    ///
    /// assert_eq!(individual.genome(), &80);
    /// ```
    fn from((genome, test_results): (G, R)) -> Self {
        Self::new(genome, test_results)
    }
}

impl<G: Eq, R: Ord> Ord for EcIndividual<G, R> {
    /// Compare two individuals based on their test results.
    ///
    /// # Example
    /// ```
    /// # use ec_core::individual::ec::EcIndividual;
    /// #
    /// let individual_a = EcIndividual::new(8, [2]);
    /// let individual_b = EcIndividual::new(-3, [100]);
    ///
    /// assert!(individual_a < individual_b);
    /// ```
    fn cmp(&self, other: &Self) -> Ordering {
        self.test_results.cmp(&other.test_results)
    }
}

impl<G: PartialEq, R: PartialOrd> PartialOrd for EcIndividual<G, R> {
    /// Compare two individuals based on their test results.
    ///
    /// # Example
    /// ```
    /// # use ec_core::individual::ec::EcIndividual;
    /// #
    /// let individual_a = EcIndividual::new(i32::MAX, [-100]);
    /// let individual_b = EcIndividual::new(i32::MAX, [300]);
    ///
    /// assert!(individual_a < individual_b);
    /// ```
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        self.test_results.partial_cmp(&other.test_results)
    }
}

impl<G: Display, R: Display> Display for EcIndividual<G, R> {
    /// Display the genome and test results of the individual.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{}]\n{}", self.genome(), self.test_results())
    }
}

/// A [`Distribution`] for creating individuals, which requires a genome
/// [`Distribution`] and a scorer.
///
/// The genome [`Distribution`] is used to create the genome of the individual,
/// and then the scorer is used to score the genome.
///
/// # Example
/// ```
/// # use rand::distr::{StandardUniform, Distribution};
/// # use ec_core::individual::{
/// #     Individual,
/// #     ec::{EcIndividual, IndividualDistribution},
/// #     scorer::FnScorer
/// # };
/// #
/// // StandardUniform is a `rand` distribution allowing
/// // us to generate i32's uniformly as genomes for this example
/// let genome_distribution = StandardUniform;
/// let scorer = FnScorer(|x: &i32| 100_i32.abs_diff(*x));
///
/// let individual_distribution = IndividualDistribution::new(genome_distribution, scorer);
///
/// let my_individual: EcIndividual<_, _> = individual_distribution.sample(&mut rand::rng());
/// #
/// # assert!((i32::MIN..=i32::MAX).contains(my_individual.genome()));
/// # assert!((u32::MIN..=u32::MAX).contains(my_individual.test_results()));
/// ```
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct IndividualDistribution<GD, S> {
    pub genome_distribution: GD,
    pub scorer: S,
}

impl<GD, S> IndividualDistribution<GD, S> {
    /// Create a new `IndividualDistribution` with the given genome generator
    /// and scorer.
    ///
    /// # Example
    /// ```
    /// # use rand::distr::{StandardUniform, Distribution};
    /// # use ec_core::individual::{
    /// #     Individual,
    /// #     ec::{EcIndividual, IndividualDistribution},
    /// #     scorer::FnScorer
    /// # };
    /// #
    /// // StandardUniform is a `rand` distribution allowing
    /// // us to generate i32's uniformly as genomes for this example
    /// let genome_distribution = StandardUniform;
    /// let scorer = FnScorer(|x: &i32| 100_i32.abs_diff(*x));
    ///
    /// let individual_distribution = IndividualDistribution::new(genome_distribution, scorer);
    /// #
    /// # let my_individual: EcIndividual<_, _> = individual_distribution.sample(&mut rand::rng());
    /// #
    /// # assert!((i32::MIN..=i32::MAX).contains(my_individual.genome()));
    /// # assert!((u32::MIN..=u32::MAX).contains(my_individual.test_results()));
    /// ```
    pub const fn new(genome_distribution: GD, scorer: S) -> Self {
        Self {
            genome_distribution,
            scorer,
        }
    }
}

/// A trait for adding a scorer to a genome [`Distribution`], creating
/// an [`IndividualDistribution`].
///
/// This trait is blanket-implemented for any `T` as such it's not meant to be
/// implemented externally.
pub trait WithScorer {
    /// Add a scorer to the genome [`Distribution`], creating an
    /// [`IndividualDistribution`].
    ///
    /// This is a chainable version of [`IndividualDistribution::new`].
    ///
    /// # Example
    /// ```
    /// # use rand::distr::{StandardUniform, Distribution};
    /// # use ec_core::individual::{
    /// #     Individual,
    /// #     ec::{EcIndividual, WithScorer},
    /// #     scorer::FnScorer
    /// # };
    /// #
    /// // StandardUniform is a `rand` distribution allowing
    /// // us to generate i32's uniformly as genomes for this example
    /// let individual_distribution =
    ///     StandardUniform.with_scorer(FnScorer(|x: &i32| 100_i32.abs_diff(*x)));
    /// #
    /// # let my_individual: EcIndividual<_, _> = individual_distribution.sample(&mut rand::rng());
    /// #
    /// # assert!((i32::MIN..=i32::MAX).contains(my_individual.genome()));
    /// # assert!((u32::MIN..=u32::MAX).contains(my_individual.test_results()));
    /// ```
    fn with_scorer<S, G>(self, scorer: S) -> IndividualDistribution<Self, S>
    where
        Self: Sized,
        S: Scorer<G>;

    /// Convenience function to directly use a closure as a scorer, which will
    /// then be turned into a [`FnScorer`]
    ///
    /// # Example
    /// ```
    /// # use rand::distr::{StandardUniform, Distribution};
    /// # use ec_core::individual::{
    /// #     Individual,
    /// #     ec::{EcIndividual, WithScorer}
    /// # };
    /// #
    /// // StandardUniform is a `rand` distribution allowing
    /// // us to generate i32's uniformly as genomes for this example
    /// let individual_distribution = StandardUniform.with_scorer_fn(|x: &i32| 100_i32.abs_diff(*x));
    /// #
    /// # let my_individual: EcIndividual<_, _> = individual_distribution.sample(&mut rand::rng());
    /// #
    /// # assert!((i32::MIN..=i32::MAX).contains(my_individual.genome()));
    /// # assert!((u32::MIN..=u32::MAX).contains(my_individual.test_results()));
    /// ```
    fn with_scorer_fn<F, G, R>(self, f: F) -> IndividualDistribution<Self, FnScorer<F>>
    where
        Self: Sized,
        F: Fn(&G) -> R,
    {
        self.with_scorer(FnScorer(f))
    }
}

impl<GD> WithScorer for GD {
    fn with_scorer<S, G>(self, scorer: S) -> IndividualDistribution<GD, S>
    where
        S: Scorer<G>,
    {
        IndividualDistribution::new(self, scorer)
    }
}

impl<GenomeT, GenomeDistributionT, ScorerT> Distribution<EcIndividual<GenomeT, ScorerT::Score>>
    for IndividualDistribution<GenomeDistributionT, ScorerT>
where
    GenomeDistributionT: Distribution<GenomeT>,
    ScorerT: Scorer<GenomeT>,
{
    /// Generate a new, random, individual.
    ///
    /// This creates a new genome of type `GenomeT` using the
    /// `GenomeDistributionT`, and then scores the genome using the scorer of
    /// type `ScorerT`.
    ///
    /// The genome and the test results (of type `S::Score`) are
    /// then used to create a new `EcIndividual`.
    ///
    /// # Example
    /// ```
    /// # use rand::distr::{StandardUniform, Distribution};
    /// # use ec_core::individual::{
    /// #     Individual,
    /// #     ec::{EcIndividual, WithScorer}
    /// # };
    /// #
    /// // StandardUniform is a `rand` distribution allowing
    /// // us to generate i32's uniformly as genomes for this example
    /// let individual_distribution = StandardUniform.with_scorer_fn(|x: &i32| 100_i32.abs_diff(*x));
    ///
    /// let my_individual: EcIndividual<_, _> = individual_distribution.sample(&mut rand::rng());
    ///
    /// assert!((i32::MIN..=i32::MAX).contains(my_individual.genome()));
    /// assert!((u32::MIN..=u32::MAX).contains(my_individual.test_results()));
    /// ```
    fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> EcIndividual<GenomeT, ScorerT::Score> {
        let genome = self.genome_distribution.sample(rng);
        let test_results = self.scorer.score(&genome);

        EcIndividual::new(genome, test_results)
    }
}
